




阻止冒泡事件

currentTarget


效果-----------------
尺寸





鼠标指针的位置
偏移
滚动一定距离导航栏固定


jquery插件





















什么样是合理的
困扰大家的问题仍然是一些前现代社会的问题

DOM元素 就是DOM对象  
jquery对象 是包装DOM对象后产生的对象 $("div")  $作为jquery的快捷方式


jquery对象 转 DOM对象 :[index]和 get(index)
	
	jquery 对象是一个数组对象 通过 [index]方法 和 get(index)方法得到相应的DOM对象
	var $cr = $("#cr");    //jquery对象  
	var cr  = $cr[0];      //DOM对象
	var cr  = $cr.get(0);

DOM对象 转 jquery对象
 加 $()
 
选择器-----
		
		1.基本选择器
			$("#id")            //ID选择器
			$("div")            //元素选择器
			$(".classname")     //类选择器
			$(".classname,.classname1,#id1")     //组合选择器
		2.层次选择器
			$("#id>.classname ")    //所有的直接子元素
			$("#id .classname ")    //后代元素选择器
			$("div+p ")    //每个 <div> 元素紧邻的下一个 <p> 元素 只选取第一个 
			$("#id ~ .classname ")    //所有同级元素
		3.过滤选择器(重点)
			$("li:first")    //第一个li
			$("li:last")     //最后一个li
			$("li:even")     //挑选下标为偶数的li
			$("li:odd")      //挑选下标为奇数的li
			$("li:eq(4)")    //下标等于4的li
			$("li:gt(2)")    //下标大于2的li
			$("li:lt(2)")    //下标小于2的li
			$("li:not(#runoob)") //挑选除 id="runoob" 以外的所有li
		3.2内容过滤选择器
		
			$("div:contains('Runob')")    // 包含 Runob文本的元素
			$("td:empty")                 //不包含子元素或者文本的空元素
			$("div:has(selector)")        //含有选择器所匹配的元素
			$("td:parent")                //含有子元素或者文本的元素
		3.3可见性过滤选择器
		
			$("li:hidden")       //匹配所有不可见元素，或type为hidden的元素
			$("li:visible")      //匹配所有可见元素
		3.4属性过滤选择器
		
			$("div[id]")        //所有含有 id 属性的 div 元素
			$("div[id='123']")        // id属性值为123的div 元素
			$("div[id!='123']")        // id属性值不等于123的div 元素
			$("div[id^='qq']")        // id属性值以qq开头的div 元素
			$("div[id$='zz']")        // id属性值以zz结尾的div 元素
			$("div[id*='bb']")        // id属性值包含bb的div 元素
			$("input[id][name$='man']") //多属性选过滤，同时满足两个属性的条件的元素
		3.5状态过滤选择器
		
			$("input:enabled")    // 匹配可用的 input
			$("input:disabled")   // 匹配不可用的 input
			$("input:checked")    // 匹配选中的 input
			$("option:selected")  // 匹配选中的 option
		4.表单选择器
			$(":input")      //匹配所有 input, textarea, select 和 button 元素
			$(":text")       //所有的单行文本框，$(":text") 		等价于$("[type=text]")，推荐使用$("input:text")效率更高，下同
			$(":password")   //所有密码框
			$(":radio")      //所有单选按钮
			$(":checkbox")   //所有复选框
			$(":submit")     //所有提交按钮
			$(":reset")      //所有重置按钮
			$(":button")     //所有button按钮
			$(":file")       //所有文件域    <input type="file" />              
		
		5.子元素选择器
		    :first-child     第一个子元素。
		    :first-of-type   第一个兄弟元素。
		    :nth-child()     第n个子元素
		    :nth-of-type()   第n个同级兄弟元素
		 	:only-child      选择只有一个子元素的
		 
		
		
		最快的选择器：id选择器
		
		最慢的选择器：伪类选择器和属性选择器 


 过滤器-------------------
   $('div').has('p'); // 选择包含p元素的div元素

　　$('div').not('.myClass'); //选择class不等于myClass的div元素

　　$('div').filter('.myClass'); //选择class等于myClass的div元素

　　$('div').first(); //选择第1个div元素

　　$('div').eq(5); //选择第6个div元素
   
    $('div').next('p'); //选择div元素后面的第一个p元素

　　$('div').parent(); //选择div元素的父元素

　　$('div').closest('form'); //选择离div最近的那个form父元素

　　$('div').children(); // 搜索直接子节点 仅在DOM树中向下遍历一层 

　　$('div').siblings(); //选择div的同级元素 不包括自己
 
 链式操作 ---------------------  
 		$('div').find('h3').eq(2).html('Hello');

链式调用原理 就是每次方法执行完后返回this对象，这样后面的方法就可以继续在this环境下执行

 取值和赋值 getter setter--------------------
 　.html() 取出或设置html内容

　　.text() 取出或设置text内容

　　.attr() 取出或设置某个属性的值

　　.width() 取出或设置某个元素的宽度

　　.height() 取出或设置某个元素的高度

　　.val() 取出某个表单元素的值
 
 移动-----------------
	
  
	
	内部插入
		A.append(B)
		B.appendTo(A)
		prepend()    //插入到匹配元素里面作为它的第一个子元素
		prependTo()
	外部插入
		after()    参数添加到后面
		before()   参数添加到前面    
  
		insertAfter  对象在后
		insertBefore 对象在前


 复制 删除 创建---------------
 	clone() 复制

 	empty()  清空元素内容但不删除内容
 	
 	remove()  detach()前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用




 工具方法-----------------
 	如果你懂得Javascript语言的继承原理，那么就能理解工具方法的实质。它是定义在jQuery构造函数上的方法，即jQuery.method()，所以可以直接使用。而那些操作元素的方法，是定义在构造函数的prototype对象上的方法，即jQuery.prototype.method()，所以必须生成实例（即选中元素）后使用。如果不理解这种区别，问题也不大，只要把工具方法理解成，是像javascript原生函数那样，可以直接使用的方法就行了。
 
　　$.trim() 去除字符串两端的空格。

　　$.each() 遍历一个数组或对象。
    each: function( callback ) {
		return jQuery.each( this, callback );
	},

　　$.inArray() 返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。

　　$.grep() 查找满足过滤函数的数组元素。原始数组不受影响。
		var arr = [ 1, 9, 3, 8, 6, 1, 5, 9, 4, 7, 3, 8, 6, 9, 1 ];
        arr = jQuery.grep(arr, function (value,index) {return value>=5;});

　　$.extend() 将多个对象，合并到第一个对象。

　　$.makeArray() 将对象转化为数组。

　　$.type() 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。

　　$.isArray() 判断某个参数是否为数组。

　　$.isEmptyObject() 判断某个对象是否为空（不含有任何属性）。

　　$.isFunction() 判断某个参数是否为函数。
	源码：
	function inFunction(obj){
		return Object.prototype.toString.call(obj) === "[object Function]";
	}


　　$.isPlainObject() 判断某个参数是否为用"{}"或"new Object"建立的对象。

　　$.support() 判断浏览器是否支持某个特性。
	$.map() 将一个数组中的元素转换到另一个数组中。
		$.map( [0,1,2], function(n){
 		 return n + 4;
		});
 







效果-----------------


	隐藏 显示
		hide()  $(selector).hide(speed,callback);
		show()  $(selector).show(speed,callback);
		 
		toggle() 模拟鼠标连续点击事件
	 
	
	滑动
		slideDown()   下滑
		slideUp()     上滑
		slideToggle() 切换
	
	
	fadeIn 淡入
	fadeOut 淡出 
	fadeToggle  切换
	
		$(document).ready(function(){
		  $("button").click(function(){
		    $("#div1").fadeIn();
		    $("#div2").fadeIn("slow");
		    $("#div3").fadeIn(3000);
		    });
		  });
	
	fadeTo() 允许指定渐变的不透明度  0-1 之间
		$("button").click(function(){
		  $("#div1").fadeTo("slow",0.15);
		  $("#div2").fadeTo("slow",0.4);
		  $("#div3").fadeTo("slow",0.7);
		});
	
	animate 自定义 动画   

var div = $('#test-animate');
div.animate({
    opacity: 0.25,
    width: '256px',
    height: '256px'
}, 3000); // 在3秒钟内CSS过渡到设定值

	$(selector).animate({params},speed,callback);
	
		$("button").click(function(){
		  $("div").animate({
		    left:'250px',
		    opacity:'0.5',
		    height:'150px',
		    width:'150px'
		  });
		});
		
		累加动画
			$("div").animate({left:"+=500px"},300)
	
		回调 
		$("#panel").click(function() {
	    $(this).animate({
	        left: "400px"
	    },
	    3000,
	    function() {
	        $(this).css("border", "5px solid blue");
	    })
	    });
	
	
	    $("div").click(function() {
	    $(this).animate({
	        left: "400px"
	    },
	    3000).queue(function(next) {
	        $(this).css("border", "5px solid blue");
	        next();
	    }).slideUp("slow");
	
	
	
	   queue 队列
	   显示 <span> 元素中队列的长度：
	
			$("span").text(div.queue().length);
	
			queue() 方法显示被选元素上要执行的函数队列 常与 dequeue() 方法一起使用。
	
			队列是一个或多个等待运行的函数。
			
		
		停止动画	 
			 $("#panel").stop(); 
			 $(selector).stop(stopAll,goToEnd);
			 stopAll  是否清除动画队列。默认是 false，仅停止当前的动画，后面的可以执行。
	         goToEnd  是否立即完成当前动画。默认是 false。
	
	
	



		


		
尺寸
 内部尺寸
 innerWidth = width+padding
 innerHeight		
 尺寸图：http://www.runoob.com/images/img_jquerydim.gif
 
 外部尺寸
 outerWidth = width+padding+border
 outerWidth(true) =  width+padding+border+margin


节点类型
  元素  1
  属性  2 
  文本  3
  注释  8
  文档  9




{}+{} 
"[object Object][object Object]"

[]+{}
"[object Object]"

console.log({}+[])
[object Object]

{}+[]  
根据语句优先原则  {}被理解为复合语句块，因此相当于 {}; +[]   。[]为空，结果为0
{}会隐式调用toString()方法，将{}转化为原始值"[object Object]"
以{}开头的会被解析为语句块

此时+为一元操作符，非字符串拼接符

[]会隐式调用toString()方法，将[]转化为原始值 ''

+'' 被转化为数字0

扩展：如果将其用()括起来，即({}+[])，此时会显示"[object Object]"，因为此时{}不再被解析为语句块




禁止右键
$(document).ready(function() {
    //catch the right-click context menu
    $(document).bind("contextmenu",function(e) {                
        //warning prompt - optional
        alert("No right-clicking!");
 
        //delete the default context menu
        return false;
    });
});



轮播

	<div id="banner">
	    <ul>
	        <li><a href="#"><img src="http://www.jq22.com/img/cs/500x300-1.png" alt=""></a></li>
	        <li><a href="#"><img src="http://www.jq22.com/img/cs/500x300-2.png" alt=""></a></li>
	        <li><a href="#"><img src="http://www.jq22.com/img/cs/500x300-3.png" alt=""></a></li>
	    </ul>
	</div>
	* {
		margin:0;
		padding:0
	}
	li {
		list-style:none
	}
	#banner {
		width:500px;
		height:300px;
		overflow:hidden
	}
	#banner ul {
		height:100%;
	}
	#banner ul li {
		width:500px;
		height:100%;
		float:left
	}
	#banner ul li img {
		width:100%;
		height:100%;
	}
	var $bannerUl=$('#banner ul'),$bannerLi=$('#banner ul li');
	    //动态获取ul的宽度
	    $bannerUl.css('width',$bannerLi.width()*$bannerLi.length);
	    setInterval(function(){
	        $bannerUl.animate({
	            'marginLeft':-$bannerLi.width()
	        },500,function(){
	            $(this).animate({'marginLeft':0},0)
	                .find('li').eq(0).appendTo($(this));
	            //把每次移动后的第一个li放到ul的最后面
	            /*
	            * 由于把第一个li放到ul的最后面，就会把第二个li挤到第一个li的位置，但是我们又需要显示第二个li，
	            * 所以需要移动回原点，但是这个移动过程不能被看到，所以执行时间是0
	            */
	        });
	    },3000);


    





   
next 同类兄弟元素

is() 
	$("ul").click(function(event) {
	 var $target = $(event.target);
	 if ( $target.is("li") ) {
	   $target.css("background-color", "red");
	 }
	});

  

find()查找元素的后代元素  
    $("p").find("span").css('color','red');

eq
$('li').eq(2).css('background-color', 'red');

siblings() 选择元素所有的同级元素 不选自己
	var len = $(".hilite").siblings()
                      .css("color", "red")
                      .length;

   
filter() 方法返回符合一定条件的元素 可以是选择器、jQuery 对象、一个或多个元素
	$("p").filter(".intro")
		
	$("p").filter(document.getElementById("intro")).css("background-color","yellow");
		
	$(document).ready(function(){
			$("p").filter(function(){  
				return $("span",this).length==2;}).css("background-color","yellow");
		});

not()方法返回不符合条件的元素  与 filter()相反
	$("p").not(".intro")


  


callbacks.add()    添加函数到回调列表中
callbacks.fire()   掺入指定的参数调用所有的回调
	$(function(){
		var foo = function(value){
			alert("foo: "+value);
		}
		 
		var callbacks = $.Callbacks();
		callbacks.add(foo);
		callbacks.fire("hello")
	
	})







html 设置或返回html内容
	$("p").html("Hello <b>world</b>!");

css 设置样式
 	$("p").css("color","red");


表单 


addclass 添加类
	$("p").addClass("selected");

toggleclass 切换类

removeclass 删除类
	$("p").removeClass();


.val 设置或返回元素的值
	$("input").val("hello world!"); 



attr 设置或返回选定元素的属性值
 	$("img").attr({ src: "test.jpg", alt: "Test Image" });
 


锋利的jquery

隔行变色
例1
$("tr:odd").css("background","red" )

例2
$(function(){
	  $("tbody>tr:odd").addClass("odd"); //先排除第一行,然后给奇数行添加样式
      $("tbody>tr:even").addClass("even"); 
      $("tbody>tr").click(function(){
        $(this)
                .addClass("selected")  //添加蓝色样式 下一次点击 上一个蓝色没有消失 最后全都变蓝   
                .siblings().removeClass("selected") //删除兄弟元素的样式  当前对象变成了$(this).siblings() 所以时间都是绑定在兄弟元素上的
                .end()//后退一步
                .find(":radio").attr("checked",true);
      });
      $('tbody>tr:has(:checked)').addClass('selected');

    })


 $(function(){
		$("tbody>tr:odd").addClass("odd");
		$("tbody>tr:even").addClass("even");
		$('tbody>tr').click(function() {
			//判断当前是否选中
			var hasSelected=$(this).hasClass('selected');
			//如果选中，则移出selected类，否则就加上selected类
			$(this)[hasSelected?"removeClass":"addClass"]('selected')
				//查找内部的checkbox,设置对应的属性。
				.find(':checkbox').attr('checked',!hasSelected);
		});
		// 如果复选框默认情况下是选择的，则高色.
		$('tbody>tr:has(:checked)').addClass('selected');
  })



5.22  表格展开关闭
	$(function(){
	  $("tr.parent").click(function(){
	    $(this).toggleClass("selected").siblings('.child_'+this.id).toggle();
	  });
	 })
	
5.23 表格内容筛选
	$("tr:contains('王五')").addClass("selected");
	
	通过文本框搜索表格内容

 	 $(function(){
 	      $("#filterName").keyup(function(){
		      $("table tbody tr")
						.hide()
						.filter(":contains('"+( $(this).val() )+"')")
						.show();
		   }).keyup();
 	 })


5.32 选项卡
	$(function(){
	      var $div_li =$("div.tab_menu ul li");
	      $div_li.click(function(){
	      $(this).addClass("selected")                //点击项添加class 同级兄弟元素删除class 显示一个重点
	           .siblings().removeClass("selected");   
	            var index =  $div_li.index(this);   
	            alert(index)
	      $("div.tab_box > div")     
	          .eq(index).show()    
	          .siblings().hide();  
	    })
	  })



6 ajax





	open(method,url,async) 用于创建请求
	参数：
		method：请求方式 get post
		URL：要请求的地址
		async：是否异步 一般为true
	
	send(data) 用于发送请求
	参数：
		data：要发送的数据 字符串类型
	 
	setRequestHeader(header, value)  用于设置请求头
	参数：
		header：请求头的key
		value： 请求头的value
	
	getAllResponseHeaders() 获取所有的响应头
	
	getResponseHeaders(header) 获取响应头中指定header的值
	参数：
		header：请求头的key
	
	abort() 终止请求
	
	ajaxComplete()	规定 AJAX 请求完成时运行的函数
	ajaxError()	规定 AJAX 请求失败时运行的函数
	ajaxSend()	规定 AJAX 请求发送之前运行的函数
	ajaxStart()	规定第一个 AJAX 请求开始时运行的函数
	ajaxStop()	规定所有的 AJAX 请求完成时运行的函数
	ajaxSuccess()	规定 AJAX 请求成功完成时运行的函数
	load()	从服务器加载数据，并把返回的数据放置到指定的元素中
	serialize()	编码表单元素集为字符串以便提交
	serializeArray()	编码表单元素集为 names 和 values 的数组
	
	
	
	responseText 服务器返回的数据字符串
	
	responseXml  服务器返回的数据 xml对象
	
	readystate  状态值
	详细：
		0 未初始化 未调用open方法
		1 启动  已调用open 未调用send
		2 发送  已调用send 未收到响应
		3 接受  已收到部分响应 
		4 完成  已接受全部响应
	
	number states 状态码 200  404 
	
	string statesText 状态文本 ok  not found
	
	














做决定前倾向于无限度收集尽可能多的资讯   

总体架构 三部分
入口模块
	jquery() 
	
底层支持模块
	选择器sizzle
	队列
	数据缓存
	浏览器功能测试
	异步队列
	回调函数列表
	工具方法 
功能模块
	属性操作
	事件系统
	dom遍历
	dom操作
	样式操作
	异步请求
	动画



原型继承
jquery.fn相当于原型的别名
jquery.fn =jquery.prototype={ }



$相当于jquery类的别名
var $ = jquery = funvtion(){}

添加成员
jquery.fn = jquery.prototype={
	jquery:"1.3",          //原型属性
	size:function(){       //原型方法
		return this,length;
	}
}



返回实例
	var $ = jquery = function(){
		return jquery.fn.init();  //调用原型方法init构造器
	}

跨域访问
	jquery框架巧妙的利用原型传递解决了问题  它把 jquery.fn 传递给 jquery.fn.init.prototype
	也就是说 用jquery的原型对象覆盖init构造器的原型对象 从而实现跨域访问

选择器
	jquery对象是一个类数组对象
	
	<div></div>
	<div></div>
	<div></div>
	<script>
		var $ = jquery = function(selector, context){ //定义类
			return new jquery.fn.init(selector, context);//返回选择器的实例                                                
		}
		jquery.fn = jquery.prototype = {       //jquery类的原型对象
			init:function(selector,context){   //定义选择器构造器
				selector = selector||document; //设置默认值为document
				context = context||document;
	
				if(selector.nodeType){ //如果选择符为节点对象
					this[0]=selector;  //把参数节点传递给实例对象数组
					this.length = 1;   //设置对象length属性
					this.context = selector; //设置属性实例 返回选择范围
					return this;   //返回当前实例
				}	
	
			},
			jquery:"1.3.2",
			size:function(){
				return this.length;
			}
		}
		jquery.fn.init.prototype=jquery.fn;
		alert($("div").size()); //返回3
	</script>
	  */
	


迭代器

	1. jquery 对象是一个集合  不是一个个体对象  因此不能用Javascript直接操作他
	2. jquery对象实际上是一个普通对象   因为他通过new创建的新对象可以继承原型方法和属性
	
	3. jquery对象 是对象和类数组的混合体
	
	4. jquery对象包含的数据都是dom元素 是通过数组形式存储的 通过jquery[i]获取 
		jquery又  模仿了Array  的基本特性
	
	5. jquery对象不能直接操作 只有分别读取他包含的每一个dom元素 才能实现各种操作
	
	在jquery对象上调用HTML方法
	$("div").html()   
	
	
	操作jquery包含的所有dom元素 这个功能是怎样实现的？ 选择器+方法
	
	jquery定义了一个工具函数each() 遍历所有dom元素 并把操作步骤封装到一个回调函数 在dom元素上调用即可
	
	
	jquery.each(array,callback)
	jquery.each(object,callback)
	
	jquery.each = function( object, callback,args){
		for (var i = 0; i < object.length; i++) {
			callback.call(object[i],args);
		}
		return object;
	}

功能拓展

	jquery通过extend拓展功能
	extend把指定的参数对象包含的所有属性复制给 jquery.prototype 这样就可以在应用中调用他们了

		var $ = jquery = function(selector, context){ //定义类
				return new jquery.fn.init(selector, context);//返回选择器的实例                                                
			}
			jquery.fn = jquery.prototype = {       //jquery类的原型对象
				init:function(selector,context){   //定义选择器构造器
				 }}
			jquery.fn.init.prototype=jquery.fn;
		 
		jquery.extend = jquery.fn.extend = function(obj){
			for(var i in obj){
				this[i] = obj[i];
			}
			return this;
		}
		
		jquery.fn.extend({
			test:function(){
				alert("测试拓展功能")
			}
		})
		
		$("div").test();


参数处理

	使用对象直接量作为参数进行传递


命名空间
	var jquery = widow.jquery = window.$ = function(selector,context){
		return new jquery.fn.init(selector,context)
	}
	
	匿名函数是最好的封闭方式 此时只需要提供接口 就可以与外界进行联系 
	
	(function(){
		function f1(){
			return 123;
		};
	})();



	
	function f2(){
		return 456;
	}
	
	alert(f2());
	alert(f1());
	

选择器接口

	$(" ")   我们知道每当我们执行$()时，就会重新生成一个init的实例对象  用一个变量保存起来后续使用即可


	jquery 提供了唯一的接口 使选择器与外界交流  这个对象是如何生成的？
	
	jquery的基础是查询  并在此基础上构建和运行查询过滤器  
	
	查询的结果是获取dom元素  内部定义了一个集合用来存放结果 
	
	(function(){
		var window = this ;
		jquery = window.jquery = window.$ = function(selector,context){
			return new jquery.fn.init(selector ,context);
		};
		jquery.fn = jquery.prototype = {
			init:function(selector ,context){
				alert(selector);
			}
		};
	
	})();
	window.onload = function(){
		$("#wrap",document.forms[0]);
	}
	
	<div id="wrap"></div>  */
	

构造器
	jquery对象是jquery.fn.init构造器创建的对象   jquery.fn.init.prototype = jquery.fn 
	
	对象 jquery.fn 
	构造函数 jquery.fn.init
	原型 jquery.fn.init.prototype
	
	
    var $ = jquery = function(selector, context){ //定义类
		return new jquery.fn.init(selector, context);//返回选择器的实例                                                
	}

	//所有jquery对象方法都通过jquery原型对象来继承
	jquery.fn = jquery.prototype = {  
	     //参数说明：selector 选择器 可以是任意数据类型 
	     //         context：山下文 指定在文档中哪个节点开始进行查询      
		init:function(selector,context){  
			//第一种情况 选择符是dom元素 忽略第二个参数  
			selector = selector||document;  
			context = context||document;

			if(selector.nodeType){ //如果选择符为节点对象
				this[0]=selector;  //把参数节点传递给实例对象数组
				this.length = 1;   //设置对象length属性
				this.context = selector; //设置属性实例 返回选择范围
				return this;   //返回当前实例
			}	



		}
	}




	init构造器   参数：selector context 
		1. 参数是dom元素 直接忽略第二个参数 把dom元素存到jquery对象的集合中 返回该jquery对象
		
		2. 参数是字符串 
				三种情况：
					HTML标签 第二个参数可选 执行selector = jquery.clean() 该语句能够把HTML字符串转换成dom对象的数组
					#id字符串 使用 getElementById获取元素 
					css选择符字符串  return jquery().find()
		
		3. 参数是函数
		
			$(document).ready(fn)
			return jquery(docuemt)[jquery.fn.ready?"ready":"load"](selector)
			
			先执行jquery(document) 再通过new jquery.fn.init()创建对象 此时元素为 document 再调用这个对象的ready()方法 并返回当前的jquery对象
		
	
	
生成dom元素

	jquery.clean() 		
		
	参数 
		
		对于数字类型的参数 会被转换成字符串
		对字符串类型的参数 会把他转换成dom元素 再存入返回的数组中 转换的方式是 把HTML字符串片段赋值给创建div元素的innerHTML 这样就可以把HTML字符串片段挂到dom文档树中 从而实现把字符串转换成dom元素

选择器引擎 


	$("div.red")  先遍历找到标签名div 再找到class
	$("div p")    先找到p  再去找div

	选择器  调用原生 选择元素 
	过滤器  通过表达式过滤


	$('div.red#wrap p')
	步骤：
		选择dom文档树中所有的p元素 建立初步结果集
		在结果集中 选择父级元素为div的元素 形成新的结果集
		再筛选class为red的元素
		再次筛选id等于wrap的元素 返回结果集
	



sizzle引擎结构
jquery.find = sizzle
jquery.filter = sizzle.filter
jquery.expr= sizzle.selectors

sizzle构造器
jquery.fn.init()-->jquery.find()-->sizzle()-->sizzle.find()

sizzle过滤器
jquery.filter() 
 
 


类数组 
	jquery.fn.prototype = new Array()
	jquery.fn.prototype.constructor = jquery


操作数组
 


	eq 返回指定位置元素 从0计算
		eq:function(i){
			return this.slice(i,+i+1)  // +i 会转换为数字  
		}
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

	toArray 将jQuery对象集合恢复成DOM数组
		$("div").toArray()
	
	
		toArray: function() {
			return slice.call( this );
		},
		
		toArray: function() {
	        return slice.call( this, 0 );
	    },
	

	$.makeArray(obj)
	将类数组对象转换为数组


	get: function( 1 ) {
		if ( 1== null ) {
			return slice.call( this );
		}
		return 1< 0 ? this[ 1+ this.length ] : this[ 1];
	},
	例子：
		<ul>
			<li>123</li>
			<li>123</li>
		</ul>
		console.log($("ul li").get(1));//<li>123</li>
		console.log($("ul li").get()); //[li,li]


	//取一个元素数组并将其推入堆栈
    //(返回新的匹配元素集)
	pushStack: function( elems ) {

		//将 elems 合并到 jQuery 对象中
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},



	merge: function(first, second) { //将第2个参数中的各个参数拼接到第1个参数的尾部
	    var len = +second.length,
	      j = 0,
	      i = first.length;
	    for(; j < len; j++) {
	      first[i++] = second[j];
	    }
	    first.length = i;
	    return first;
	  }

	pushStack() 函数用于将一个DOM元素集合加入到jQuery栈。
	$(function () { 
	    $().pushStack( document.getElementsByTagName("div"));
	})
	
	jquery内部有着一个 jQuery 对象栈，用来维护所有已经操作过的 jQuery 对象
	
	在jQuery对象中，每个对象都有一个prevObject属性。
	
	问题1：这个属性什么时候创建？？----->>> 只要你创建了jQuery对象就会产生
	问题2：在哪里创建？？------>>>> 在一个pushStack()方法里产生
	问题3：作用??? ----->>>>指向操作前的jQuery对象引用





	

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},


	$("div").constructor
	结果：jQuery = function( selector, context ) {
			return new jQuery.fn.init( selector, context );
		},



    end: function() {
		return this.prevObject || this.constructor();
	},
	例子：
		两个ul
		$('ul.first').find('.foo').css('background-color', 'red')
		.end().find('.bar').css('background-color', 'green');
		//end() 返回调用 find() 之前的状态  
	复制
	
	slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	添加
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?this.prevObject : this.prevObject.filter( selector )
			);
		}
	过滤
	filter(元素||对象||表达式||函数)  返回符合一定条件的元素。
	$("p").filter(":even").css("background-color","red");
	$("p").filter("#id").css("background-color","red");
	$("p").filter($("div")).css("background-color","red");
	
	find() 方法返回被选元素的后代元素。
		html所有后代
		$("html").find("*").css({"color":"red"});
		body的指定后代
		$("body").find("div,li,.1").css({"color":"red"});
	映射
	map


	去重
	$.unique(arr)
 

	$.merge(arr1, arr2)
		合并数组，会改变第一个参数的数组为合并之后的数组，返回合并之后的数组
		
		var arr = [1, 3, 4];
		var arr2 = [4, 3, 1];
		$.merge(arr, arr2);
		// > [1, 3, 4, 4, 3, 1]
		// 为了防止第一个数组被改变，可以使用下面的方式来写
		$.merge($.merge([], arr), arr2);








 
jquery选择器永远返回一个数组对象 没有找到元素则返回空数组对象
判断一个jquery对象是否存在 应该使用数组长度来判断 if($("div").length > 0){}
 
 Sizzle.contains( a, b )
检测元素a是否包含元素b 

Sizzle.uniqueSort() 
排序 去重


Sizzle.selectors.find() 查找函数集
Sizzle.selectors.preFilter() 预过滤函数集
Sizzle.selectors.filters() 伪类过滤函数集

预过滤函数在过滤函数 Sizzle.selectors.filter[ type ] 之前被调用

Sizzle.filter() → Sizzle.selectors.filter.PSEUDO() → Sizzle.selectors.filters
 
Sizzle.filter() → Sizzle.selectors.filter.POS() → Sizzle.selectors.setFilters



选择器表达式
	块表达式
		id class element
		属性表达式
		伪类表达式
	块间关系符
	    + > ~ " "

查找步骤
	处理选择器表达式： 解析 块表达式  关系符
	处理块表达式和关系符：  查找 过滤 缩小范围 



ID选择器
	js实现
	<div id="div1">测试盒子</div>  //
	window.onload = function(){  //页面初始化函数
		var e = document.getElementById("div1")  //选择id等于divi的元素
		e.style.background = "red";
	   }
	jquery实现
	window.onload = function(){
		var e = $("#div1");
		e[0].style.background = "red";
	
	}
	
	
	执行效率  循环生成1000个span元素
	
	js			 
	window.onload = function(){
		for(var i = 0; i<1000; i++){
			var span = document.createElement("span");
			span.setAttribute("id","span"+i);
			 var textnode=document.createTextNode("1");
			span.appendChild(textnode);
			document.getElementsByTagName('body')[0].appendChild(span)
		};
		var a =[];
		var t1 =new Date();
		for(var j = 0; j<1000; j++){
			var b = document.getElementById('span'+j);
			a.push(b);
		}
		var t2 = new Date();
		console.log(t2-t1+"毫秒");
	
	}
	jq 
	var a =[];
	var t1 =new Date();
	 for(var i = 0; i<1000; i++){
	 var s = $("span");
	 a.push(s);
	 
	 }
	var t2 = new Date();
	console.log(t2-t1+"毫秒");



	 如果id选择器中有特殊字符 要转义
	 比如 <div id="[div]"></div>  --> $("#\\[div\\]")
	 //为什么会这样？  因为jquery用正则表达式来匹配参数值 

element选择器

	getElementsByTagName() 返回值是所选 元素集合的数组对象引用

	js
	
		window.onload= function(){
			var div = document.getElementsByTagName("div");
			for(var i=0; i<div.length; i++){
				div[i].style.color = "red";
			}
		}
	
	jq 
		$(function(){
			$("div").css("color","red");
		})
	
	
类选择器

	document.getElementsByClassName("red");
	$(".red").css("color","red");


过滤器

定位过滤器
	:first
		first:function(elem, i){
			return i === 0;
		}   
	:last
		last:function(elem, i, match, array){
			return i === array.length-1;
		}     
	:even  
		even:function(elem, i){
			return i % 2 === 0;
		}   
	:odd  
		odd:function(elem, i){
			return i % 2 === 1;
		}       
	:eq(4)    //下标等于4的li
		eq: function( elem, i, match ) {
		    return match[3] - 0 === i;
		  }
	
	
	:gt(2)    //下标大于2的li
	:lt(2)    //下标小于2的li
	在大于2的下标里选择小于2的下标
	$("li:gt(2):lt(2)").attr("color", "red");
	 


内容过滤器
:contains

:empty
	empty:function(elem){   //不存在子元素 返回true     
		return !elem.firstChild;
	}
:parent
	parent:function(elem){   //存在子元素 返回true     
		return !!elem.firstChild;
	}
:has
	has:function(elem,i, match){  //调用Sizzle函数检测指定表达式匹配的元素是否存在  存在-->true
		return !!Sizzle(match[3],elem).lenth;
	}

可见过滤器

hidden  宽高等于0  
visible 宽高大于0

表单选择器 
通过元素的type属性来判断


正则

	g全局匹配 i 忽略大小写 
	
		.  单个字符 
		*  零次到n次
		\w = [A-Za-z0-9_]   匹配字母、数字、下划线    不能匹配符号
	    \s = [ \f\n\r\t\v]  匹配任何空白字符，包括空格、制表符、换页符等等。
	    \d = [0-9]
	
	test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false
	
	从b中搜索a
	var a = new RegExp("e");
	var b = "free";
	document.write(a.test(b));
	
	
	str.match()
		全局查找字符串 "ain"，且不区分大小写:
		
		var str="The rain in SPAIN stays mainly in the plain"; 
		var n=str.match(/ain/gi);
		输出结果:ain,AIN,ain,ain
	
	str.replace()
		执行一个全局替换, 忽略大小写:
		
		var str="Mr Blue has a blue house and a blue car";
		var n=str.replace(/blue/gi, "red");
		输出结果:Mr red has a red house and a red car
	
	str.search()	
		执行一次忽略大小写的检索:
		
		var str="Mr. Blue has a blue house";
		document.write(str.search(/blue/i));
		输出结果：4
		











DOM 

文档 表现层  它将根据文档结构创建文档对象
对象 逻辑层  用来完成特定的任务
模型 交互层  用来描述文档的结构


创建元素 
	var $h1 = $("<h1></h1>")
	$("body").append($h1);
	
	var h1 = document.createElement("h1")
	document.body.appendChild(h1)
	
	var $h1 = $("<h1>文本</h1>")
	var TXT= document.createTextNode("1123");
	
	var $h1 = $("<h1 id="one">文本</h1>")
	h1.setAttribute("id","one")
	
插入元素 
	锚点--> insertAfter

删除元素  remove()

复制元素
	$(function(){
		$("div").click(function(){
			var $div = $("div").clone(true); //参数为true  会复制事件
			$div.insertBefore("div")
		})	
	})


	<div onclick="alert('ok')">
		<p>段落文本</p>
	</div>


包裹 解开
	在p元素外包裹一层div
	$(document).ready(function(){
		$("#btn1").click(function(){
			$("p").wrap("<div></div>");
		});
		$("#btn2").click(function(){
			$("p").unwrap();
		});
	});
	
	给每个p元素包裹一层div
	$("p").wrapInner("<div></div>");
	
	用一个div包裹所有的p
	$("p").wrapAll("<div></div>");


替换
$("p:first").replaceWith($("p:last"));  先删除再覆盖
$("<span><b>Hello world!</b></span>").replaceAll("p");  

操作属性
	设置属性
	$(function(){
		$("p").attr("title","段落文本")
	
	})
	
	获取属性
	$("p").attr("title")
	
	删除属性
	$("p").removeAttr("title");

操作类样式

	添加类
	$("p").addClass("red");
	删除类
	$("p").removeClass() //删除所有类
	切换类
	$("p").toggleclass("hidden");
	判断类
	$("p").hasClass("red");
	

操作html

	锚点--> html()


操作样式 

	绝对偏移 以窗口左上角为原点 的偏移量 
	
		点击button设置偏移
		<div class="c1"></div>
		<button>change</button>
		$("button").click(function () {
		        $(".c1").offset({"top":100,left:200})
		    })
	
	
	设置p 偏移坐标等于span的偏移坐标 
		$(document).ready(function(){
			$("button").click(function(){
				$("p").offset($("span").offset());
			});
		});
		<p>这是一个段落。</p>
		<button>设置p元素的偏移坐标等于span元素</button>
		<span style="position:absolute;left:100px;top:150px;">这是一个span</span>
		设置p 偏移坐标等于span的偏移坐标 
		
	position
		$(document).ready(function(){
			$("button").click(function(){
				x=$("p").position();
				$("#span1").text(x.top);
				$("#span2").text(x.left);
			});
		});
		<div style="border:1px solid black;padding:100px;margin:50px;">
		<p>这一段的位置(相对于它的父元素)是<span id="span1">x</span> top 和 <span id="span2">x</span> left.</p>
		<button>获取位置</button>
	
	

元素遍历 

锚点--> children()




/*






简写 $()

	$(document).ready(function(){}) 等于 $(function(){})
	
	$(document) =$()
	
	$().ready(function(){})
	
	window.onload方法是在页面所有的元素(包括元素所有关联的文件)完全加载到浏览器后才执行 
	$(document).ready()方法注册的事件管理程序 在DOM完全就绪就可以被调用
	
	$(window).load(function(){}) 等价于 window.onload=function (){}
	
	-----------
	
	on 
	$("p").on("click",function(){});
	$("p").click(function(){});
	
	trigger ---------------
	 
	$("#btn").trigger('click')
	 
	$("#btn").click()//当使用click而不带任何参数的时候，结果将是触发操作而不是绑定行为

	
	
	$(selector).hide() ≈$(selector).css('display','hidden')		
	
	
事件
	.on(  事件 [, 选择器 ] [,event.data  ], handler(eventObject) ) 
	 handler()：事件被触发时，执行的函数。若该函数只是要执行return false的话，那么该参数位置可以直接简写成 false。
	
	    绑定多个事件
	    $("div").on("mouseover mouseout",function(){});
	
		在指定元素上绑定一个或多个事件处理函数
		 
			function myHandler(event) {
			  alert(event.data.foo); //结果：bar
			}
			$("p").on("click", {foo: "bar"}, myHandler)
		
		取消表单的提交动作，并且通过返回 false 的方法来防止事件冒泡：
			$("form").on("submit", false)
		
		
		
		通过使用 .stopPropagation()，防止提交事件的冒泡行为，但是并不禁止提交行为。
		 
			$("form").on("submit", function(event) {
			  event.stopPropagation();
			});
		
	
	one() 为每个div绑定一次性click事件
		$("p").one("click", function(){
		alert( $(this).text() );
		});
	
	off
		移除所有 <p> 元素上的 click 事件：
		
		$("button").click(function(){
		$("p").off("click");
		});
	
	

	模拟用户操作 
	trigger  触发器

		$(function(){
		$("p").click(function(){
			$("p").text("单击事件");
	
		});
		$("p").mouseover(function(){
			$("p").trigger("click")
		});
	    })
	
		传递数据
			trigger(type,[data]) 
			type 事件类型  
			data 要传递给事件处理函数的附加数据 数组形式
	
	
		给事件传递参数
		 $("p").click( function (event, a, b) {
		  // 一个普通的点击事件时，a和b是undefined类型
		  // 如果用下面的语句触发，那么a指向"foo",而b指向"bar"
		 } ).trigger("click", ["foo", "bar"]);
		
	triggerHandler()	
		不会触发浏览器默认事件
		只触发jquery对象集合中第一个元素的事件处理函数
		返回的是事件处理函数的返回值 不是jquery对象 所以不可链

		$("input").triggerHandler("focus") //只触发绑定的focus事件 不获得焦点

     相同事件名称 不同命名空间 
	$(function(){
		$("div").bind("click",function(){
		       $("body").append("<p>click事件</p>");
		});
		$("div").bind("click.plugin", function(){
		       $("body").append("<p>click.plugin事件</p>");
		});
		$("button").click(function() {
			  $("div").trigger("click!");    // 注意click后面的感叹号
		});
	  })

	源码
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	  






	显示按键字母
	document.addEventListener('keydown', (event) => {
	  const keyName = event.key;
	  alert('keydown event\n\n' + 'key: ' + keyName);
	});


	事件切换
		hover 
		$(document).ready(function(){
		  $("p").hover(function(){
		    $("p").css("background-color","red");
		    },function(){
		    $("p").css("background-color","pink");
		  });
		});
	






	
每个 event 都是 jQuery.Event 的实例
	



	event.type        获取事件类型    
	event.data.value  数据值   当前正在执行的处理程序绑定时，一个可选的数据对象传递给一个事件方法。
	       
	event.target属性返回 哪个DOM元素触发了事件
		event.target.href 获取触发事件的href属性
	
		$(document).ready(function(){
		  $("p, button, h1").click(function(event){
		    $("div").html("通过 " + event.target.nodeName + " 元素触发。"); 通过 p 元素触发。
		  });
		});
		
	evnet.relatedTarget  属性返回当鼠标移动时哪个元素进入或退出。
		$("div,p").mouseenter(function(event){
	  	  $("#id").html("关联的目标为: " + event.relatedTarget.nodeName);
	    });
	
	altKey   alt键
	ctrlKey  Ctrl键
	shiftKey shift键
	which    哪一个键 返回数字码
	

	
	event.pageX  指针位置
		<p>鼠标指针在: <span></span></p>
		$(document).mousemove(function(event){ 
		    $("span").text("X: " + event.pageX + ", Y: " + event.pageY); 
		  });
		
	event.which 按了那个键
		 $("input").keydown(function(event){ 
 		   $("div").html("Key: " + event.which);
 		 });
		输入字符: <input type="text">
	哪一个鼠标键
	$("div").mousedown(function(event){ 
    	$("div").append("鼠标 " + event.which+"键被按下");
  	});
 
	event.originalEvent()   指向原始的事件对象
	
	
	
	弃用的事件
		bind   绑定 
		unbind 解绑
		toggle 切换事件



    把阻止冒泡和阻止默认 改写为 return false

	阻止冒泡事件
	
	        $("a").click(function (e) {
	            e.stopPropagation();
	        });
	 
	
	事件
	
	        $("a").click(function (e) {
	            e.preventDefault();
	        });
	 
	
	和冒泡事件
	
	        $("a").click(function (e) {
	            return false;
	        });
	





事件委托
比如，有一个表格（table元素），里面有100个格子（td元素），现在要求在每个格子上面绑定一个点击事件（click），请问是否需要将下面的命令执行100次？
	因为td元素发生点击事件之后，这个事件会"冒泡"到父元素table上面，从而被监听到。只需要在父元素绑定1次即可  这就叫事件的"委托处理"，也就是子元素"委托"父元素处理这个事件。


delegate()
	$(selector).delegate(childSelector,event,data,function)
	
	源码
	    delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
	
	向函数传递数据
	
		function handlename(e){
			alert(e.data.msg)
		}
		$(function(){
			$("p").delegate({msg:"你点击了它"},"click",handlename)
		})
		<p>请点击</p> /
		
		
		$("div").delegate("p","click",function(){
	      $("p").css("background-color","pink");
		});



delegateTarget

	1.<button> 直接绑定事件，delegateTarget 和 currentTarget 是相等的。</button> 
	  
		$(function(){
			$("button").on("click",function(event){
				alert( "delegateTarget返回："+event.delegateTarget.nodeName+"\n currentTarget 返回"+event.currentTarget.nodeName);
			});
		});
		
	2.<button> 委托事件  delegateTarget显示委托对象body   currentTarget显示触发对象button </button>
	 
		$(function(){
			$("body").on("click","button",function(event){
				alert( "delegateTarget返回："+event.delegateTarget.nodeName+"\n currentTarget 返回"+event.currentTarget.nodeName);
			});
		});
	
	例 ：//
		<div>
	        外层div元素
	        <span id="one">内层span元素</span>
	    </div>
	    $(function(){
			$("body").on("click","#one",function(event){
			alert( "delegateTarget返回："+event.delegateTarget.nodeName+"\n currentTarget 返回"+event.currentTarget.nodeName);
		    });
	    });  
	

插件


分为三种类型
	jquery方法！！！
		把一些常用和重复使用的定义为函数 绑定到jquery对象上 从而成为jquery对象的一个拓展方法
		这种插件是将对象方法封装起来 在jquery选择器获取jquery对象过程中进行操作 从而发挥jquery强大的选择器优势 
	
	全局函数
		可以把自定义的功能函数独立附加到jquery命名空间下 从而作为jquery作用域下的一个公共函数使用 例如 ajax()方法就是内部定义的全局函数
		全局函数没有绑定到jquery对象上  不能在选择器获取的对象上调用  需要通过jquery.fn()方式进行引用
	
	选择器
	
		如果觉得 有些选择器不好用 可以自己定义
	


插件机制

	jQuery.extend() (要大写Q)    创建全局函数或 选择器 
	jQuery.fn.extend()  创建jQuery对象方法
	例子：自定义方法 
		jQuery.extend({
		    min: function(a, b) {
		        return a < b ? a : b;
		    },
		    max: function(a, b) {
		        return a > b ? a : b;
		    }
		});
		console.log(jQuery.min(2, 3)) //  2 
		console.log(jQuery.max(4, 5)) //  5
	
	
	为插件方法传递参数
		function fn(options){
		var options = jQuery.extend( {
			name:name,
			data: data,
			handler: handler, 
		   }, options);
		
		}
	fn({name:sky})	//覆盖新值
	fn({name2:name2,name3:name3}) //添加新选项
	fn() //保持默认参数


创建jQuery全局函数

	所谓全局函数 就是jQuery对象的方法 位于jQuery命名空间内部的函数
	
	ajax()方法是一个典型的全局函数 $.ajax()所做的一切都可以通过调用名称为ajax()的全局函数来实现 
	
	
	不推荐写法   
	jQuery.min=function(){
		return a < b ? a : b;
	}
	
	jQuery.max=function(a, b) {
	    return a > b ? a : b;
	}
	
	使用命名空间 避免名字冲突  （将新函数指定为jQuery的一个属性  可以用$代替jQuery 但是不推荐  在编写插件时应该始终使用jQuery来调用jQuery方法）
	jQuery.abc ={
	    min: function(a, b) {
	        return a < b ? a : b;
	    },
	    max: function(a, b) {
	        return a > b ? a : b;
	    }
	}
	var x = jQuery.abc.min(a,b);
	var y = jQuery.abc.max(a.b);
	



使用 jquery.fn对象 创建jQuery对象方法

	创建 全局函数   只需要给jQuery对象添加属性即可 
	创建 jQuery对象 给jQuery.fn添加属性即可  jQuery.fn=jQuery.prototype  
	
	
	jQuery.fn.test = function(){
		alert("这是jQuery对象方法")
	}
	
	$(function(){
		$("p").click(function(){
			$(this).test()  //函数体内的this 总是指向当前jQuery对象
		})
	})
	
	
	当前jQuery对象的节点名称
	
	jQuery.fn.test = function(){
		alert(this[0].nodeName);  //jQuery选择器返回的是数组类型的DOM集合 this指向这个集合 要显示当前元素的节点名称 就要在this指针后面指定当前元素的序号
	}
	$(function(){
		$("p").click(function(){
			$(this).test()   
		})
	})
	

	如何让jQuery选择器匹配多个元素   用each()的迭代方式 让this指针依次指向

	jQuery.fn.test = function(){
		this.each(function(){     //遍历所有匹配的元素 this表示对象集合 
			alert(this.nodeName);  //显示当前元素的节点名称  此处的this表示元素对象
		});
	}
	
	$(function(){
		$("body *").click(function(){ //选择body下的所有元素
			$(this).test();
		});
	})
	<input type="button" value="按钮">
     <div>div元素</div>
     <p>p元素</p>
     <span>span元素</span> // 返回的标签名全部是大写

使用 jQuery.fn.extend()方法  创建jquery对象方法  

	jQuery.fn.extend({  //只有一个参数 是一个对象直接量 以键值对形式组成多个属性或方法
		test:function(){
			return this.each(function(){      
				alert(this.nodeName);   
			});		
		}
	})
	形式1
		(function($) {
		    $.fn.extend({
		        pluginName: function(opt, callback) {
		            // Our plugin implementation code goes here.        
		        }
		    })
		})(jQuery);   
	
	形式2
		(function($) {
		    $.fn.pluginName = function() {
		        // Our plugin implementation code goes here.      
		    };
		})(jQuery);
		


// 创建一个闭包     
(function($) {     
  // 插件的定义     
  $.fn.hilight = function(options) {     
    debug(this);     
    // 在元素迭代之前构建主选项    
    var opts = $.extend({}, $.fn.hilight.defaults, options) 
    // 迭代并重新格式化每个匹配的元素  
    return this.each(function() {     
      $this = $(this);     
      // 构建元素特定选项    
      var o = $.meta ? $.extend({}, opts, $this.data()) : opts;     
      // 更新元素的风格   
      $this.css({     
        backgroundColor: o.background,     
        color: o.foreground     
      });     
      var markup = $this.html();     
      // 调用格式化函数     
      markup = $.fn.hilight.format(markup);     
      $this.html(markup);     
    });     
  };     
  // 私有函数：debugging     
  function debug($obj) {     
    if (window.console && window.console.log)     
      window.console.log('hilight selection count: ' + $obj.size());     
  };     
  // 定义暴露format函数     
  $.fn.hilight.format = function(txt) {     
    return '<strong>' + txt + '</strong>';     
  };     
  // 插件的defaults     
  $.fn.hilight.defaults = {     
    foreground: 'red',     
    background: 'yellow'     
  };     
// 闭包结束     
})(jQuery); 



创建自定义选择器 

	lt:function(lelm , i , match){
		return i<match[3]-0
	}
	
	参数解析：
		elem  表示当前遍历的元素对象
		i     表示当前元素在所有匹配元素中的引索位置
		match 表示 执行匹配后返回的数组对象 
	
	match参数说明：
		match[0] 表示"p:lt(2)" 部分字符串
		match[1] 表示选择器引导符 ：
		match[2] 表示选择器函数   lt
		match[3] 表示选择器函数中的序号参数 
		match[4] 比如 p:lt(a(b))  表示 b这个部分
	
	jQuery.expr[":"] = jQuery.expr.filters = sizzle.selectors.filters
	
	自定义选择器
		jQuery.exted(jQuery.expr[":"],{
			xxx:function(){},
			xxx:function(){}
		})
	
优化默认选择器

对默认选择器重写
	第一种 直接覆盖 （不推荐）
		jQuery.expr[":"].nth-child = function(elem, i, match){ 函数体}   //nth-child 中的 - 会被看减号
	
	第二种 调用jQuery.extend()方法重写（推荐）
		jQuery.extend(jQuery.expr[":"],{
			"nth-child":function(elem, i, match){ 函数体}
		})
		



封装插件

	第一步 定义一个独立域
		(function($){
			//自定义插件代码
		})(jQuery)
	
	第二步 确定插件类型 选择创建方式
	
		创建一个设置字体颜色的插件 则应该创建jQuery对象方法
	
		(function($){
			$.extend($.fn,{  //jQuery对象方法拓展方法 
				//函数
			})
		})(jQuery)
	
	把所有的参数以列表形式封装在选项对象中进行传递  例如：对于设置字体的插件 应该允许用户设置颜色 同时还应该考虑如果用户没有设置颜色 则应确保使用默认颜色进行设置
	 (function($){
	 	$.extend($.fn,{
	 		color:function(options){
	 			var options = $.extend({
	 				bg_color:"white",
	 				font_color:"black"
	 			},options);
	 		}
	 	})
	 })(jQuery)
	
	完整版
	(function($){
	 	$.extend($.fn,{
	 		color:function(options){
	 			var options = $.extend({
	 				bg_color:"white",
	 				font_color:"black"
	 			},options);
	 			return this.each(function(){
	 				$(this).css("color",options.font_color);
	 				$(this).css("backgroundColor",options.bg_color);
	 			})
	 		}
	 	})
	 })(jQuery)
	
	测试color方法
	
	$(function(){
		$("h1").color({
			bg_color:"red",
			font_color:"black"
		});
	})
	
	<h1>标题文字</h1>
	//



优化插件

开放公共参数

	以开放的姿态满足不同个性化需求 同时做好封闭 避免有意无意的破坏
	
	首先 考虑开放插件的默认设置 
	
	把上面例子的参数默认值作为 $.fn.color对象 的属性单独进行设计 然后借助jQuery.extend()方法覆盖原来的参数选项即可
	(function($){
		$.extend($.fn,{
			color:function(options){
				var options = $.extend({},$.fn.color.defaults,options);  //覆盖原来的参数
				return this.each(function(){
					$(this).css("color",options.font_color);
					$(this).css("backgroundColor",options.bg_color);
				})
			}
		})
		$.fn.color.defaults = {  //独立设置对象的默认值
		 	bg_color:"white",
		 	font_color:"black"		
		}
	})(jQuery)
	
	没有设置options参数值 则使用defaults属性值
	$(function(){
		$.fn.color.defaults = {   //预设默认值
				bg_color:"red",
				font_color:"black"
		}
		$("h1").color();  //为标题设置默认值
		$("p").color({bg_color:"#eee"});
		$("div").color();
	})
	
		 <h1>标题文字</h1>
		 <p>段落文字</p>
		 <div>盒子</div>

		 //
	

开放部分功能

 一个插件有很多功能  但是没办法封装所有的功能 
  通过开放部分功能 允许用户重写  从而满足不同需求

以color插件为例 我们为其添加一个格式化的拓展功能  比如加粗 斜体

	(function($){
		$.extend($.fn,{
			color:function(options){
				var options = $.extend({},$.fn.color.defaults,options);  //覆盖原来的参数
				return this.each(function(){
					$(this).css("color",options.font_color);
					$(this).css("backgroundColor",options.bg_color);
					var _html = $(this).html();   //获取当前元素包含的HTML字符串
					_html = $.fn.color.format(_html);  //调用格式化功能函数对其进行格式化
					$(this).html(_html);  //使用格式化的HTML字符串重写当前元素内容
				})
			}
		})
		$.fn.color.defaults = {  
		 	bg_color:"white",
		 	font_color:"black"		
		}
		$.fn.color.format = function(str){
			return str;
		};
	})(jQuery)


	$(function(){
		$.fn.color.format = function(str){    //拓展color()插件的功能 使内部文本加粗显示
			return "<strong>"+str+"</strong>"
		}
		$("h1").color();  
        $("p").color({bg_color:"#eee"});
         
        $.fn.color.format = function(str){   
			return "<strong>"+str+"</strong>"
		}
		$("div").color();
    })




保留插件隐私  闭包

	若插件包含很多函数 在设计时我们希望这些函数不扰乱命名空间 也不完全暴露 唯一的方法就是使用闭包 将整个插件封装到一个函数中

	为了验证用户输入的参数是否合法 我们定义了一个参数验证函数  这个函数不允许外界访问 用闭包把它藏起来 只允许内部访问
	

	(function($){
		$.extend($.fn,{
			color:function(options){
				if(!filter(options))
					 return this;
				var options = $.extend({},$.fn.color.defaults,options);  //覆盖原来的参数
				return this.each(function(){
					$(this).css("color",options.font_color);
					$(this).css("backgroundColor",options.bg_color);
					var _html = $(this).html();   //获取当前元素包含的HTML字符串
					_html = $.fn.color.format(_html);  //调用格式化功能函数对其进行格式化
					$(this).html(_html);  //使用格式化的HTML字符串重写当前元素内容
				})
			}
		})
		$.fn.color.defaults = {  
		 	bg_color:"white",
		 	font_color:"black"		
		}
		$.fn.color.format = function(str){
			return str;
		};

		function filter(options){  //定义隐私函数 外界无法访问
			return !options ||(options && typeof options ==="object")?true:false;

		}
	})(jQuery)


	$(function(){
		 $("p").color();
		$("div").color(*#￥%……); //参数错误
    })

非破坏性操作

(function($){
	$.extend($.fn,{
		parent:function(options){
			var arr = [];
			$.each(this,function(index,value){
				arr.push(value.parentNode);
			});
			arr = $.unique(arr);
			return this.pushStack(arr);
		}
	})
})(jQuery);

$(function(){
	var $p= $("p");
	$p.parent().css("border","solid 1px red").end().hide()
})
$(function(){
	var $p= $("p");
	$p.parent().css("border","solid 1px red").end().hide()  //只有p消失
	//$p.parent().css("border","solid 1px red").hide()      //全部都消失
})

 <div style="width:400px;height:200px;">大盒子
	<p>段落文本1</p>
		<div style="width:200px;height:100px;">小盒子
			<p>段落文本2</p>
		</div>
</div>

//


添加事件日志

(function($){
	$.extend($.fn,{
		log:function(msg){
			var html = jQuery('<div class="log"></div>').text(msg);
			return this.each(function(){
				jQuery(".logbox").append(html);
			})
		}	
	})
})(jQuery);

$(function(){
	$("input").click(function(event){
		var e = event.type;
		$(this).log(this.nodeName+"."+e)
	});
	$("p").mouseover(function(event){
		var e = event.type;
		$(this).log(this.nodeName+"."+e)
	});
	$("h1").mouseout(function(event){
		var e = event.type;
		$(this).log(this.nodeName+"."+e)
	});

})

<h1>标题文本</h1>
<input type="button" value="提交"/>
<p>段落文本</p>
<div class="logbox"></div>


     
(function($){
	$.extend($.fn,{
		log:function(msg){
			return this.each(function(){
				var $this = $(this); //获取当前元素
				while($this.length){  //如果存在当前元素
					var $logbox = $this.find(".logbox");
					if($logbox.length){
						var html = jQuery('<div class="log"></div>').text(msg);
						$logbox.append(html);
						break;  //跳出检索
					}
					$this = $this.parent();  //检索上一级匹配元素

				}
			})

			
			 
		}	
	})
})(jQuery);

$(function(){
	$("input").click(function(event){
		var e = event.type;
		$(this).log(this.nodeName+"."+e);
	});
	$("p").mouseover(function(event){
		var e = event.type;
		$(this).log(this.nodeName+"."+e);
	});
	$("h1").mouseout(function(event){
		var e = event.type;
		$(this).log(this.nodeName+"."+e);
	});

})
	 

(function($){
	$.extend($.fn,{
		log:function(msg){
			if(typeof msg =="object"){  //如果参数是对象类型 则解析该对象包含的信息
				var str = "{";
				$.each(msg,function(name,value){  //遍历对象成员
					str+=name+":"+value+",";
				});
				str = str.substring(0, str.length-2); //清除最后一个成员的逗号 value后面的逗号 
				str+="}";
				console.log(str);  //{nodeName:P,eventtype:mouseove}
				msg = str; //把解析的对象信息返回给参数变量

			}
			return this.each(function(){
				var $this = $(this); //获取当前元素
				while($this.length){  //如果存在当前元素
					var $logbox = $this.find(".logbox");
					if($logbox.length){
						var html = jQuery('<div class="log"></div>').text(msg);
						$logbox.append(html);
						break;  //跳出检索
					}
					$this = $this.parent();  //检索上一级匹配元素

				}
			}) 
		}	
	})
})(jQuery);


$(function(){
	$("h1").mouseout(function(event){
		$(this).log({
			nodeName:this.nodeName,
			eventtype:event.type
		});
	});
	$("p").mouseover(function(event){
		$(this).log({
			nodeName:this.nodeName,
			eventtype:event.type
		});
	});


})

<h1>标题文本</h1>
<input type="button" value="提交"/>
<p>段落文本</p>
<div class="logbox"></div>

插件注意问题

在插件中this总是指向jquery对象 有利链式操作

在each遍历中 this指向当前匹配的元素

除非特定需求外 都必须返回jquery对象

javascript框架也可能使用 $ 别名  

建议使用这种写法 (function($){})(jQuery)






       
animate插件

(function($){
	$.extend($.fn,{
		showin:function(speed,fn){
			return this.animate({
				height:"show",
				opacity:"show"				 
                 
			},speed,fn);
		},
		hideout:function(speed,fn){
			return this.animate({
				height:"hide",
                opacity:"hide"				 
                 
			},speed,fn);
		}		
	})
})(jQuery)

 $(function(){
	$("input").eq(0).click(function(){
		$("div").hideout(2000);
	})
	$("input").eq(1).click(function(){
		$("div").showin(2000);
	})	
})

  <input type="button" value="收起"/>
  <input type="button" value="展开"/>
  <div style="height:200px;width:300px; background-color:red; border:1px solid red"></div>
//







去掉俩边空格
str = jQuery.trim(str);

序列化 $.param 该序列化值可在进行 AJAX 请求时在 URL 查询字符串中使用
$(document).ready(function(){
  personObj=new Object();
  personObj.firstname="Bill";
  personObj.lastname="Gates";
  
  $("button").click(function(){
    $("div").text($.param(personObj));
  });
});


解决 $ 名字冲突
      
	noConflict:function(deep){
		window.$ = _$;
		if(deep)
			window.jQuery = _jQuery;
		return jQuery;
	}
	使用noConflict后 就要把所有的 $ 换成 jQuery
	 
	$.noConflict();
	jQuery(document).ready(function(){
	  jQuery("button").click(function(){
	    jQuery("p").text("jQuery 仍然在工作!");
	  });
	});
	
	

解决 jQuery 名字冲突
$.noConflict(true);  如果参数为true 则使用临时变量_jQuery恢复它的最初功能

数据缓存

如果数据是数组并且很大 需要多次引用 会造成系统资源紧张  转换成json 就可直接读取了 不需要重复引用 

设置数据
$("div").data("blah", "hello");  // blah设置为hello

读取缓存数据 
$("div").data("blah");  // hello

修改数据
$("div").data("blah", 86);  // 设置为86

删除数据
$("div").removeData("blah");  //移除blah



jQuery(function(){
	$("#menu li").data("type","menu");
	$("#news li").data("type","news");
	$("li").each(function(index){
		if($(this).data("type")=="menu"){
			$(this).text("导航菜单"+(index+1))
		}
		else if($(this).data("type")=="news"){
			$(this).removeDate('news')
		}
	})
})
<ul id="menu">
         <li>1</li>
         <li>2</li>
         <li>3</li>
     </ul> 
     <ul id="news">
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
document是window对象的属性  他引用Document




移动框架 jQuery Mobile ,jQTouch,Sencha Touch

zepto 、underscore、backbone


javascript是手  jquery是笔

CRUD
是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。crud主要被用在描述软件系统中数据库或者持久层的基本操作功能。


异步请求  dom操作   







懒加载 

js实现
 var imgs = document.getElementsByTagName('img');
    // 获取视口高度与滚动条的偏移量
    function lazyload(){
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        var viewportSize = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        for(var i=0; i<imgs.length; i++) {
            var x =scrollTop+viewportSize-imgs[i].offsetTop;
            if(x>0){
                imgs[i].src = imgs[i].getAttribute('loadpic');   
            }
        }
    }

    setInterval(lazyload,1000);



/**
* 图片的src实现原理
*/
$(document).ready(function(){
    // 获取页面视口高度
    var viewportHeight = $(window).height();
    var lazyload = function() {
        // 获取窗口滚动条距离
        var scrollTop = $(window).scrollTop();
        $('img').each(function(){
        // 判断 视口高度+滚动条距离 与 图片元素距离文档原点的高度         
        var x = scrollTop + viewportHeight - $(this).position().top;
        // 如果大于0 即该元素能被浏览者看到，则将暂存于自定义属性loadpic的值赋值给真正的src            
        if (x > 0)
        {
            $(this).attr('src',$(this).attr('loadpic')); 
        }
    })
    }
    // 创建定时器 “实时”计算每个元素的src是否应该被赋值
    setInterval(lazyload,100);
});


图片懒加载
// 注意: 需要引入jQuery和underscore
$(function() {
    // 获取window的引用:
    var $window = $(window);
    // 获取包含data-src属性的img，并以jQuery对象存入数组:
    var lazyImgs = _.map($('img[data-src]').get(), function (i) {
        return $(i);
    });
    // 定义事件函数:
    var onScroll = function() {
        // 获取页面滚动的高度:
        var wtop = $window.scrollTop();
        // 判断是否还有未加载的img:
        if (lazyImgs.length > 0) {
            // 获取可视区域高度:
            var wheight = $window.height();
            // 存放待删除的索引:
            var loadedIndex = [];
            // 循环处理数组的每个img元素:
            _.each(lazyImgs, function ($i, index) {
                // 判断是否在可视范围内:
                if ($i.offset().top - wtop < wheight) {
                    // 设置src属性:
                    $i.attr('src', $i.attr('data-src'));
                    // 添加到待删除数组:
                    loadedIndex.unshift(index);
                }
            });
            // 删除已处理的对象:
            _.each(loadedIndex, function (index) {
                lazyImgs.splice(index, 1);
            });
        }
    };
    // 绑定事件:
    $window.scroll(onScroll);
    // 手动触发一次:
    onScroll();






 


jquery插件

(function($) {
    $.fn.scrollLoading = function(options) {
        var defaults = {
            // 在html标签中存放的属性名称；
            attr: "data-url",
            // 父元素默认为window
            container: window,
            callback: $.noop
        };
        // 不管有没有传入参数，先合并再说；
        var params = $.extend({}, defaults, options || {});
        // 把父元素转为jquery对象；
        var container = $(params.container);
        // 新建一个数组，然后调用each方法，用于存储每个dom对象相关的数据；
        params.cache = [];
        $(this).each(function() {
            // 取出jquery对象中每个dom对象的节点类型，取出每个dom对象上设置的图片路径
            var node = this.nodeName.toLowerCase(), url = $(this).attr(params["attr"]);
            //重组，把每个dom对象上的属性存为一个对象；
            var data = {
                obj: $(this),
                tag: node,
                url: url
            };
            // 把这个对象加到一个数组中；
            params.cache.push(data);
        });

        var callback = function(call) {
            if ($.isFunction(params.callback)) {
                params.callback.call(call);
            }
        };
        
        //每次触发滚动事件时，对每个dom元素与container元素进行位置判断，如果满足条件，就把路径赋予这个dom元素！
        var loading = function() {
            // 获取父元素的高度
            var contHeight = container.outerHeight();
            var contWidth = container.outerWidth();

            // 获取父元素相对于文档页顶部的距离，这边要注意了，分为以下两种情况；
            if (container.get(0) === window) {
                // 第一种情况父元素为window，获取浏览器滚动条已滚动的距离；$(window)没有offset()方法；
                var contop = $(window).scrollTop();
                var conleft = $(window).scrollLeft();
            } else {
                // 第二种情况父元素为非window元素，获取它的滚动条滚动的距离；
                var contop = container.offset().top;
                var conleft = container.offset().left;
            }

            $.each(params.cache, function(i, data) {
                var o = data.obj, tag = data.tag, url = data.url, post, posb, posl, posr;
                if (o) {
                    //对象顶部与文档顶部之间的距离，如果它小于父元素底部与文档顶部的距离，则说明垂直方向上已经进入可视区域了；
                    post = o.offset().top - (contop + contHeight);
                    //对象底部与文档顶部之间的距离，如果它大于父元素顶部与文档顶部的距离，则说明垂直方向上已经进入可视区域了；
                    posb = o.offset().top + o.height() - contop;

                    // 水平方向上同理；
                    posl = o.offset().left - (conleft + contWidth);
                    posr = o.offset().left + o.width() - conleft;

                    // 只有当这个对象是可视的，并且这四个条件都满足时，才能给这个对象赋予图片路径；
                    if ( o.is(':visible') && (post < 0 && posb > 0) && (posl < 0 && posr > 0) ) {
                        if (url) {
                            //在浏览器窗口内
                            if (tag === "img") {
                                //设置图片src
                                callback(o.attr("src", url));
                            } else {
                                // 设置除img之外元素的背景url
                                callback(o.css("background-image", "url("+ url +")"));
                            }
                        } else {
                            // 无地址，直接触发回调
                            callback(o);
                        }
                        // 给对象设置完图片路径之后，把params.cache中的对象给清除掉；对象再进入可视区，就不再进行重复设置了；
                        data.obj = null;
                    }
                }
            });
        };
        //加载完毕即执行
        loading();
        //滚动执行
        container.bind("scroll", loading);
    };
})(jQuery);



鼠标指针的位置
$(document).ready(function(){
  $(document).mousemove(function(event){ 
    $("span").text("X: " + event.pageX + ", Y: " + event.pageY); 
  });
});

<p> 鼠标指针：<span></span></p>


偏移

返回偏移坐标
var x=$("p").offset();
alert("上: " + x.top + " 左: " + x.left);


设置p元素的偏移坐标
$("p").offset({top:200,left:200})

累加偏移
$('button').click(function(){
	$('p').offset(function(n,c){
		newpos = new Object();
		newpos.left = c.left+100;
		newpos.top = c.top+100;
		return newpos;
	})
})


元素的高度
innerHeight() 	   包含padding
outerHeight() 	   包含padding border
outerHeight(true)  包含padding border margin 


设置或返回 滚动条的位置
$("div").scrollTop(100)  
$("div").scrollLeft()  

滚动一定距离导航栏固定
.fixnav {  
    position: fixed;  
    top: 0 px ;  
    left: 0 px;  
}  

    $(function() {  
        $(".nav2").hide();  
        $(window).scroll(function() {  
            if($(document).scrollTop() >= 200) {  
                $(".nav2").addClass("fixnav").slideDown();  
            } else {  
                $(".nav2").hide();  
            }  
        })  
    })  